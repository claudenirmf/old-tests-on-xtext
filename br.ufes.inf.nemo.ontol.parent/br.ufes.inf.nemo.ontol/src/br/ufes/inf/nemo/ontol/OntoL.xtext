// automatically generated by Xtext
grammar br.ufes.inf.nemo.ontol.OntoL with org.eclipse.xtext.common.Terminals

import "http://www.nemo.inf.ufes.br/ontol/OntoL" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	'module' name = QualifiedName '{'
		( 
			'include' includes+=[Model|QualifiedName] ';'
			| elements+=ModelElement
		)*
	'}'
;

ModelElement:
	( Import | EntityDeclaration | GeneralizationSet ) ';'
;

QualifiedName:
	ID ('.' ID)*
;

QualifiedNameWithWildcard:
	QualifiedName '.*'?
;

Import:
	'import' importedNamespace = QualifiedNameWithWildcard 
;

EntityDeclaration:
	OntoLClass | Individual
;

Individual:
	'individual' name=ID
	(':' instantiatedClasses+=[OntoLClass|QualifiedName] (',' instantiatedClasses+=[OntoLClass|QualifiedName])*)?
	('{' ( 
		attAssignments+=AttributeAssignment
		| refAssignments+=ReferenceAssignment
	)* '}')?
;

OntoLClass:
	( OrderlessClass | HOClass | FOClass ) 
	('{' ( 
		attributes+=Attribute
		| attAssignments+=AttributeAssignment
		| references+=Reference
		| refAssignments+=ReferenceAssignment
	)* '}')?
;

OrderlessClass:
	'orderless' 'class' name=ID
	(':' instantiatedClasses+=[OntoLClass|QualifiedName] (',' instantiatedClasses+=[OntoLClass|QualifiedName])*)?
	('specializes' superClasses+=[OntoLClass|QualifiedName] (',' superClasses+=[OntoLClass|QualifiedName])*)?
	('subordinatedto' subordinators+=[OntoLClass|QualifiedName] (',' subordinators+=[OntoLClass|QualifiedName])*)?
	( 
		(categorizationType=CategorizationType basetype=[OntoLClass|QualifiedName])
		| ('ispowertypeof' powertypeOf=[OntoLClass|QualifiedName])
	)?
;

FOClass:
	('first-order')? 'class' name=ID
	(':' instantiatedClasses+=[OntoLClass|QualifiedName] (',' instantiatedClasses+=[OntoLClass|QualifiedName])*)?
	('specializes' superClasses+=[OntoLClass|QualifiedName] (',' superClasses+=[OntoLClass|QualifiedName])*)?
;

HOClass:
	'order' order=INT 'class' name=ID
	(':' instantiatedClasses+=[OntoLClass|QualifiedName] (',' instantiatedClasses+=[OntoLClass|QualifiedName])*)?
	('specializes' superClasses+=[OntoLClass|QualifiedName] (',' superClasses+=[OntoLClass|QualifiedName])*)?
	('subordinatedto' subordinators+=[OntoLClass|QualifiedName] (',' subordinators+=[OntoLClass|QualifiedName])*)?
	(
		(categorizationType=CategorizationType basetype=[OntoLClass|QualifiedName])
		| ('ispowertypeof' powertypeOf=[OntoLClass|QualifiedName])
	)?
;

enum CategorizationType:
	CATEGORIZER | COMPLETE_CATEGORIZER | DISJOINT_CATEGORIZER | PARTITIONER
;

Attribute:
	(regularity?='regularity')?
	'att' name=ID ':' ('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']')?
	propertyClass=[OntoLClass|QualifiedName]
	('subsets' subsetOf+=[Attribute|QualifiedName] (',' subsetOf+=[Attribute|QualifiedName])*)?
;

Reference: 
	(regularity?='regularity')?
	'ref' name=ID ':' ('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']')?
	propertyClass=[OntoLClass|QualifiedName]
	('subsets' subsetOf+=[Reference|QualifiedName] (',' subsetOf+=[Reference|QualifiedName])*)?
	('isoppositeto' oppositeTo=[Reference|QualifiedName])?
;

ELEMENTBOUND returns ecore::EIntegerObject:
	'*' | INT
;

AttributeAssignment: 
	'att' attribute=[Attribute|QualifiedName] '='
	( 
		assignments+=DataValue 
		| '{' assignments+=DataValue (',' assignments+=DataValue)* '}'
	)
;

ReferenceAssignment: 
	'ref' reference=[Reference|QualifiedName] '='
	( 
		assignments+=ReferenceValue
		| '{' assignments+=ReferenceValue (',' assignments+=ReferenceValue)* '}'
	)
;

DataValue:
	StringValue | NumberValue | BooleanValue | NoneValue
;


ReferenceValue returns ReferenceValue:
	value=[EntityDeclaration|QualifiedName]
;

StringValue:
	value=STRING
;

NumberValue:
	value=NUMBER
;

NUMBER returns ecore::EDouble:
	 ('-')?INT('.'INT)?
;

BooleanValue:
	value=BOOLEAN
;

BOOLEAN returns ecore::EBoolean:
	'true'|'false'
;

NoneValue:
	{NoneValue} 'none'
;

GeneralizationSet:
	(
		isDisjoint?='disjoint' | isComplete?='complete'
		| isDisjoint?='disjoint' isComplete?='complete'
		| isComplete?='complete' isDisjoint?='disjoint'
	)?
	'genset' (name=ID)?
	'general' general=[OntoLClass|QualifiedName]
	('categorizer' categorizer=[OntoLClass|QualifiedName])?
	'specifics' specifics+=[OntoLClass|QualifiedName] (',' specifics+=[OntoLClass|QualifiedName])+
;
