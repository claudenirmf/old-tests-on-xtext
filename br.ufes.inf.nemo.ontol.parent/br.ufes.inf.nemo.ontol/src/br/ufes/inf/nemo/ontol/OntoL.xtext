// automatically generated by Xtext
grammar br.ufes.inf.nemo.ontol.OntoL with org.eclipse.xtext.common.Terminals

import "http://www.nemo.inf.ufes.br/ontol/OntoL" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	'module' name = QualifiedName '{'
		elements+=ModelElement*
	'}'
;

ModelElement:
	( Import | EntityDeclaration | GeneralizationSet ) ';'
;

QualifiedName:
	ID ('.' ID)*
;

QualifiedNameWithWildcard:
	QualifiedName '.*'?
;

Import:
	'import' importedNamespace = QualifiedNameWithWildcard 
;

EntityDeclaration:
	OntoLClass | Individual
;

Individual:
	'individual' name=ID
	(':' instantiatedClasses+=[OntoLClass|QualifiedName] (',' instantiatedClasses+=[OntoLClass|QualifiedName])*)?
	('{' ( 
		attAssignments+=AttributeAssignment
		| refAssignments+=ReferenceAssignment
	)* '}')?
;

OntoLClass:
	( OrderlessClass | HOClass | FOClass ) 
	('{' ( 
		attributes+=Attribute
		| attAssignments+=AttributeAssignment
		| references+=Reference
		| refAssignments+=ReferenceAssignment
	)* '}')?
;

OrderlessClass:
	'orderless' 'class' name=ID
	(':' instantiatedClasses+=[OntoLClass|QualifiedName] (',' instantiatedClasses+=[OntoLClass|QualifiedName])*)?
	('specializes' superClasses+=[OntoLClass|QualifiedName] (',' superClasses+=[OntoLClass|QualifiedName])*)?
	('subordinatedto' subordinators+=[OntoLClass|QualifiedName] (',' subordinators+=[OntoLClass|QualifiedName])*)?
	( 
		(catType=CategorizationType basetype=[OntoLClass|QualifiedName])
		| ('ispowertypeof' powertypeOf=[OntoLClass|QualifiedName])
	)?
;

FOClass:
	('first-order')? 'class' name=ID
	(':' instantiatedClasses+=[OntoLClass|QualifiedName] (',' instantiatedClasses+=[OntoLClass|QualifiedName])*)?
	('specializes' superClasses+=[OntoLClass|QualifiedName] (',' superClasses+=[OntoLClass|QualifiedName])*)?
;

HOClass:
	'order' order=INT 'class' name=ID
	(':' instantiatedClasses+=[OntoLClass|QualifiedName] (',' instantiatedClasses+=[OntoLClass|QualifiedName])*)?
	('specializes' superClasses+=[OntoLClass|QualifiedName] (',' superClasses+=[OntoLClass|QualifiedName])*)?
	('subordinatedto' subordinators+=[OntoLClass|QualifiedName] (',' subordinators+=[OntoLClass|QualifiedName])*)?
	(
		(catType=CategorizationType basetype=[OntoLClass|QualifiedName])
		| ('ispowertypeof' powertypeOf=[OntoLClass|QualifiedName])
	)?
;

enum CategorizationType:
	CATEGORIZER | COMPLETE_CATEGORIZER | DISJOINT_CATEGORIZER | PARTITIONER
;

Property:
	name=ID ':' ('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']')?
	propertyType=[OntoLClass|QualifiedName]
	('subsets' subsetOf+=[Property|QualifiedName] (',' subsetOf+=[Property|QualifiedName])*)?
	('isoppositeto' oppositeTo=[Property|QualifiedName])?
;

Attribute:
	'att' name=ID ':' ('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']')?
	propertyClass=[OntoLClass|QualifiedName]
	('subsets' subsetOf+=[Attribute|QualifiedName] (',' subsetOf+=[Attribute|QualifiedName])*)?
	('isoppositeto' oppositeTo=[Attribute|QualifiedName])?
;

Reference: 
	'ref' name=ID ':' ('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']')?
	propertyClass=[OntoLClass|QualifiedName]
	('subsets' subsetOf+=[Reference|QualifiedName] (',' subsetOf+=[Reference|QualifiedName])*)?
	('isoppositeto' oppositeTo=[Reference|QualifiedName])?
;

ELEMENTBOUND returns ecore::EIntegerObject:
	'*' | INT
;

PropertyAssignment returns PropertyAssignment:
	property=[Property|QualifiedName] '=' assignment=Value
;

AttributeAssignment: 
;

ReferenceAssignment: 
;
Value:
	ReferenceValue | ListValue | StringValue | NumberValue | BooleanValue | NoneValue
;

ReferenceValue:
	value=[EntityDeclaration|QualifiedName]
;

ListValue:
	'(' value+=Value (','value+=Value)* ')'
;

StringValue:
	value=STRING
;

NumberValue:
	value=NUMBER
;

NUMBER returns ecore::EDouble:
	 ('-')?INT('.'INT)?
;

BooleanValue:
	value=BOOLEAN
;

BOOLEAN returns ecore::EBoolean:
	'true'|'false'
;

NoneValue:
	{NoneValue} 'none'
;

// TODO Change syntax for disjoint and complete
GeneralizationSet:
	( 
		'(' isDisjoint?='disjoint'')' 
		| '(' isComplete?='complete' ')' 
		| '(' isDisjoint?='disjoint' ',' isComplete?='complete' ')'
		| '(' isComplete?='complete' ',' isDisjoint?='disjoint' ')'
	)? 
	'genset' (name=ID)?
	'general' general=[OntoLClass|QualifiedName]
	('categorizer' categorizer=[OntoLClass|QualifiedName])?
	'specifics' specifics+=[OntoLClass|QualifiedName] (',' specifics+=[OntoLClass|QualifiedName])*
;
