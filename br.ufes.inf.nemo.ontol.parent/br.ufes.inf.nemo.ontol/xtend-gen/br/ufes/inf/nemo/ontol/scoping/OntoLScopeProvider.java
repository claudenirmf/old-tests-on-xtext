/**
 * generated by Xtext 2.10.0
 */
package br.ufes.inf.nemo.ontol.scoping;

import br.ufes.inf.nemo.ontol.model.Attribute;
import br.ufes.inf.nemo.ontol.model.AttributeAssignment;
import br.ufes.inf.nemo.ontol.model.EntityDeclaration;
import br.ufes.inf.nemo.ontol.model.ModelPackage;
import br.ufes.inf.nemo.ontol.model.OntoLClass;
import br.ufes.inf.nemo.ontol.model.Reference;
import br.ufes.inf.nemo.ontol.model.ReferenceAssignment;
import br.ufes.inf.nemo.ontol.scoping.AbstractOntoLScopeProvider;
import br.ufes.inf.nemo.ontol.util.OntoLUtils;
import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.util.LinkedHashSet;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class OntoLScopeProvider extends AbstractOntoLScopeProvider {
  @Inject
  @Extension
  private OntoLUtils _ontoLUtils;
  
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    boolean _and = false;
    if (!(context instanceof AttributeAssignment)) {
      _and = false;
    } else {
      EReference _attributeAssignment_Attribute = ModelPackage.eINSTANCE.getAttributeAssignment_Attribute();
      boolean _equals = Objects.equal(reference, _attributeAssignment_Attribute);
      _and = _equals;
    }
    if (_and) {
      return this.getScopeForAttributeAssignmentOnAttributeAssignment_Attribute(context, reference);
    } else {
      boolean _and_1 = false;
      if (!(context instanceof ReferenceAssignment)) {
        _and_1 = false;
      } else {
        EReference _referenceAssignment_Reference = ModelPackage.eINSTANCE.getReferenceAssignment_Reference();
        boolean _equals_1 = Objects.equal(reference, _referenceAssignment_Reference);
        _and_1 = _equals_1;
      }
      if (_and_1) {
        return this.getScopeForReferenceAssignmentOnReferenceAssignment_Reference(context, reference);
      } else {
        boolean _and_2 = false;
        if (!(context instanceof Attribute)) {
          _and_2 = false;
        } else {
          EReference _attribute_SubsetOf = ModelPackage.eINSTANCE.getAttribute_SubsetOf();
          boolean _equals_2 = Objects.equal(reference, _attribute_SubsetOf);
          _and_2 = _equals_2;
        }
        if (_and_2) {
          return this.getScopeForAttributeOnAttribute_SubsetOf(context, reference);
        } else {
          boolean _and_3 = false;
          if (!(context instanceof Reference)) {
            _and_3 = false;
          } else {
            EReference _reference_SubsetOf = ModelPackage.eINSTANCE.getReference_SubsetOf();
            boolean _equals_3 = Objects.equal(reference, _reference_SubsetOf);
            _and_3 = _equals_3;
          }
          if (_and_3) {
            return this.getScopeForReferenceOnReference_SubsetOf(context, reference);
          } else {
            boolean _and_4 = false;
            if (!(context instanceof Reference)) {
              _and_4 = false;
            } else {
              EReference _reference_OppositeTo = ModelPackage.eINSTANCE.getReference_OppositeTo();
              boolean _equals_4 = Objects.equal(reference, _reference_OppositeTo);
              _and_4 = _equals_4;
            }
            if (_and_4) {
              return this.getScopeForReferenceOnReference_OppositeTo(context, reference);
            } else {
              return super.getScope(context, reference);
            }
          }
        }
      }
    }
  }
  
  private IScope getScopeForAttributeAssignmentOnAttributeAssignment_Attribute(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final EntityDeclaration entity = ((EntityDeclaration) _eContainer);
    final LinkedHashSet<Attribute> attributes = this._ontoLUtils.getAllAttributes(entity);
    final Function<Attribute, QualifiedName> _function = (Attribute att) -> {
      final Function1<Attribute, Boolean> _function_1 = (Attribute it) -> {
        boolean _and = false;
        String _name = it.getName();
        String _name_1 = att.getName();
        boolean _equals = _name.equals(_name_1);
        if (!_equals) {
          _and = false;
        } else {
          boolean _notEquals = (!Objects.equal(it, att));
          _and = _notEquals;
        }
        return Boolean.valueOf(_and);
      };
      boolean _exists = IterableExtensions.<Attribute>exists(attributes, _function_1);
      if (_exists) {
        EObject _eContainer_1 = att.eContainer();
        String _name = ((EntityDeclaration) _eContainer_1).getName();
        String _name_1 = att.getName();
        return QualifiedName.create(_name, _name_1);
      } else {
        String _name_2 = att.getName();
        return QualifiedName.create(_name_2);
      }
    };
    EList<AttributeAssignment> _attAssignments = entity.getAttAssignments();
    IScope _scopeFor = Scopes.scopeFor(_attAssignments);
    return Scopes.<Attribute>scopeFor(attributes, _function, _scopeFor);
  }
  
  private IScope getScopeForReferenceAssignmentOnReferenceAssignment_Reference(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final EntityDeclaration entity = ((EntityDeclaration) _eContainer);
    final LinkedHashSet<Reference> references = this._ontoLUtils.getAllReferences(entity);
    final Function<Reference, QualifiedName> _function = (Reference ref) -> {
      final Function1<Reference, Boolean> _function_1 = (Reference it) -> {
        boolean _and = false;
        String _name = it.getName();
        String _name_1 = ref.getName();
        boolean _equals = _name.equals(_name_1);
        if (!_equals) {
          _and = false;
        } else {
          boolean _notEquals = (!Objects.equal(it, ref));
          _and = _notEquals;
        }
        return Boolean.valueOf(_and);
      };
      boolean _exists = IterableExtensions.<Reference>exists(references, _function_1);
      if (_exists) {
        EObject _eContainer_1 = ref.eContainer();
        String _name = ((EntityDeclaration) _eContainer_1).getName();
        String _name_1 = ref.getName();
        return QualifiedName.create(_name, _name_1);
      } else {
        String _name_2 = ref.getName();
        return QualifiedName.create(_name_2);
      }
    };
    EList<ReferenceAssignment> _refAssignments = entity.getRefAssignments();
    IScope _scopeFor = Scopes.scopeFor(_refAssignments);
    return Scopes.<Reference>scopeFor(references, _function, _scopeFor);
  }
  
  private IScope getScopeForAttributeOnAttribute_SubsetOf(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final OntoLClass c = ((OntoLClass) _eContainer);
    final Set<Attribute> inheritedAtts = this._ontoLUtils.getAllInheritedAttributes(c);
    final Function<Attribute, QualifiedName> _function = (Attribute att) -> {
      final Function1<Attribute, Boolean> _function_1 = (Attribute it) -> {
        boolean _and = false;
        String _name = it.getName();
        String _name_1 = att.getName();
        boolean _equals = _name.equals(_name_1);
        if (!_equals) {
          _and = false;
        } else {
          boolean _notEquals = (!Objects.equal(it, att));
          _and = _notEquals;
        }
        return Boolean.valueOf(_and);
      };
      boolean _exists = IterableExtensions.<Attribute>exists(inheritedAtts, _function_1);
      if (_exists) {
        EObject _eContainer_1 = att.eContainer();
        String _name = ((EntityDeclaration) _eContainer_1).getName();
        String _name_1 = att.getName();
        return QualifiedName.create(_name, _name_1);
      } else {
        String _name_2 = att.getName();
        return QualifiedName.create(_name_2);
      }
    };
    EList<Attribute> _attributes = c.getAttributes();
    IScope _scopeFor = Scopes.scopeFor(_attributes);
    return Scopes.<Attribute>scopeFor(inheritedAtts, _function, _scopeFor);
  }
  
  private IScope getScopeForReferenceOnReference_SubsetOf(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final OntoLClass c = ((OntoLClass) _eContainer);
    final Set<Reference> inheritedRefs = this._ontoLUtils.getAllInheritedReferences(c);
    final Function<Reference, QualifiedName> _function = (Reference ref) -> {
      final Function1<Reference, Boolean> _function_1 = (Reference it) -> {
        boolean _and = false;
        String _name = it.getName();
        String _name_1 = ref.getName();
        boolean _equals = _name.equals(_name_1);
        if (!_equals) {
          _and = false;
        } else {
          boolean _notEquals = (!Objects.equal(it, ref));
          _and = _notEquals;
        }
        return Boolean.valueOf(_and);
      };
      boolean _exists = IterableExtensions.<Reference>exists(inheritedRefs, _function_1);
      if (_exists) {
        EObject _eContainer_1 = ref.eContainer();
        String _name = ((EntityDeclaration) _eContainer_1).getName();
        String _name_1 = ref.getName();
        return QualifiedName.create(_name, _name_1);
      } else {
        String _name_2 = ref.getName();
        return QualifiedName.create(_name_2);
      }
    };
    EList<Reference> _references = c.getReferences();
    IScope _scopeFor = Scopes.scopeFor(_references);
    return Scopes.<Reference>scopeFor(inheritedRefs, _function, _scopeFor);
  }
  
  public IScope getScopeForReferenceOnReference_OppositeTo(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final OntoLClass c = ((OntoLClass) _eContainer);
    final Reference ref = ((Reference) context);
    OntoLClass _propertyClass = ref.getPropertyClass();
    EList<Reference> _references = _propertyClass.getReferences();
    final Function1<Reference, Boolean> _function = (Reference it) -> {
      OntoLClass _propertyClass_1 = it.getPropertyClass();
      return Boolean.valueOf(Objects.equal(_propertyClass_1, c));
    };
    Iterable<Reference> _filter = IterableExtensions.<Reference>filter(_references, _function);
    final Function<Reference, QualifiedName> _function_1 = (Reference it) -> {
      String _name = it.getName();
      return QualifiedName.create(_name);
    };
    EList<Reference> _references_1 = c.getReferences();
    IScope _scopeFor = Scopes.scopeFor(_references_1);
    return Scopes.<Reference>scopeFor(_filter, _function_1, _scopeFor);
  }
}
